<p>
    You can also `combine` boolean operators to create more complex statements.
</p>
<p>
    For example, you can use `and` and `not` together to create a statement that checks for opposite conditions.
</p>

<code><var>a</var>, <var>b</var> = <kwd>True</kwd>, <kwd>False</kwd>
<kwd>if</kwd> <var>a</var> <kwd>and</kwd> <kwd>not</kwd> <var>b</var>:
    <fun>print</fun>(<kwd>True</kwd>) 
</code>

<p>
    Furthermore, you can use `not` together with other operators to create a
    statement that checks for multiple things then returns the opposite.
</p>

<p>
    This is acheived by using `condition priority` with `parentheses`.
</p>
<p>
    Using parentheses, you can change the order in which Python evaluates a statement.
</p>

<code><var>a</var>, <var>b</var> = <kwd>True</kwd>, <kwd>True</kwd>
<cmt># prints true, because the statement is evaluated as (not a) or (b), and b is 'True'</cmt>
<fun>print</fun>(<kwd>not</kwd> <var>a</var> <kwd>or</kwd> <var>b</var>) 
</code>

<p>
    However, if we wrap `a and b` in parentheses, the statement will be evaluated as `not (a and b)`. and the result will be `False`.
</p>
<code>
<var>a</var>, <var>b</var> = <kwd>True</kwd>, <kwd>True</kwd>
<cmt># prints false, because the statement is evaluated as not (a or b)</cmt>
<fun>print</fun>(<kwd>not</kwd> (<var>a</var> <kwd>or</kwd> <var>b</var>))
</code>
<p>
    This is because, the same as standard math, Python evaluates parentheses first.
</p>

<p>
    Given two boolean values, `a` and `b`, if `a` is `True` and `b` is `False`, print `True`. else print `True`.
</p>